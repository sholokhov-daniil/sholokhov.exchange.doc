# Конфигурация обмена


## Введение


Все основные конфигурации обмена указываются в его конструктор.  
Конфигурация представляет собой ассоциативный массив. Конфигурация обмена является защищенной на чтение и изменение из вне.
После передачи конфигурации в конструктор обмена мы больше не сможем их скорректировать и прочитать.
Могут встречаться частные случае, когда пользователю предоставляется возможность переопределить конфигурацию


Конфигурация позволяет настроить поведение вашего обмена и указать куда производится обмен.
Если указать некорректную конфигурацию, то при инициализации обмена мы можем получить исключение - стоит учесть данный момент.


Все стандартные обмены являются наследниками класса **Sholokhov\Exchange\AbstractExchange**, который позволяет настроить:
- Включение деактивации
- Результат обмена
- Карта обмена

Каждый отдельно взятый обмен содержит свои доступные параметры и значения. Все доступные обмены описаны в блоке импорт.


## Идентификатор обмена


Идентификатор обмена служит, для разграничения данных с которыми идет взаимодействия и обеспечить корректную работу обмена с одной сущностью одновременно. 
> ⚠️ Внимание
> 
> Для избежания конфликтов ситуаций рекомендуется указывать уникальный идентификатор обмена

> ⚠️ Внимание
> 
> Не каждый обмен поддерживает разграничение данных на основе идентификатора.
> Перед использованием необходимо ознакомиться с документацией используемого обмена

Одним из возможных ситуаций по которой следует указывать идентификатор - несколько импортов в одну сущность и работа только со своими элементами сущности

```php
use Ramsey\Uuid\Uuid;

$config = [
    'hash' => 'your_exchange_id'
];

new Exchange($config);


$config2 = [
    'hash' => Uuid::uuid5(Uuid::NAMESPACE_OID, 'my-key')->toString(),
];

new Exchange($config2);
```

## Включение деактивации


После обмена данных производит деактивацию всех значений, которые не приняли участие.  
По умолчанию деактивацию отключена. Логика деактивации регламентируется наследником, и она не является обязательной.
Если наследник откажется реализовывать данный функционал, то данный флаг не повлияет на результат обмена.

```php
$config = [
    'deactivate' => true,
];

new Exchange($config);
```

## Результат обмена


Каждый обмен обязан вернуть объект результата выполнения, который реализует интерфейс **Sholokhov\Exchange\Messages\ExchangeResultInterface**

Результат содержит все ошибки, которые возникли и все идентификаторы значений, которые принимали участие в импорте\экспорте.
В угоду оптимизации по умолчанию результат не хранит идентификаторы значений, и для этого нам необходимо сконфигурировать обмен.

```php
$exchange = new Exchange;
$exchange->setResultRepositoryFactory($callback);
```

Метод **setResultRepositoryFactory** принимает значение, которое является [callable](https://www.php.net/manual/en/language.types.callable.php)
и вернет новый объект хранилища реализующий интерфейс **Sholokhov\Exchange\Repository\Result\ResultRepositoryInterface**


## Карта обмена


Карта обмена хранится в отдельном хранилище **Sholokhov\Exchange\Repository\Map\MappingRegistry** у которого есть метод **setFields**, который ожидает массив объектов описывающих связи.

Разберем простой пример импорта элементов информационного блока:
Необходимо импортировать название элемента и изображение в пользовательское свойство.

```php
use Sholokhov\Exchange\Fields\Field;
use Sholokhov\Exchange\Fields\IBlock\IBlockElementField;
use Sholokhov\Exchange\Factory\Exchange\MapperFactory;

$source = [
    [
        'name' => 'Название элемента',
        'price' => 15.2
    ],
    [
        'name' => 'Еще какой-то товар',
        'price' => 17.2,
    ],
    [
        'name' => 'Хороший товар',
        'price' => 15.2,
        'image' => 'https://example/upload/image.png'
    ]
];

$map = [
    (new Field)
        ->setFrom('name')
        ->setTo('NAME')
        ->setPrimary(),
    (new IBlockElementField)
        ->setFrom('image')
        ->setTo('MORE_PHOTO')
];

$repository = MapperFactory::create();
$repository->setFields($map);

$exchange->setMappingRegistry($repository);
$exchange->execute($source);
```

## Логирование

Каждый обмен обязан производить логирование результата своей работы.
огирование реализована посредством [PSR-3](https://www.php-fig.org/psr/psr-3/), и позволяет использовать произвольный механизм журналирования.

Обмен по умолчанию не инициализирует механизм логирования, а производит делегирование на разработчика, который подключает обмен.

Рассмотрим пример указания произвольного механизма журналирования

```php
/** @var Psr\Log\LoggerInterface $logger **/
$logger = new YourLogger;

$exchange = new Exchange;
$exchange->setLogger($logger);
```

## Преобразователь

Преобразователь данных работает с нормализованными данными(обработанными и приведенными к типу данных с которой умеет работать сущность).  

Основное предназначение преобразователя:
- Изменение типа данных
- Запуск вложенного импорта, если значение свойства связано с другой сущностью


Все стандартные обмены имеют свой набор зарегистрированных преобразователей.
Обмен дает возможность указать свои пользовательские преобразователи, которые будут вызываться в первую очередь.
Преобразователь реализовывает интерфейс **Sholokhov\Exchange\Preparation\PreparationInterface**

> ⚠️ Внимание
> 
> Вызывается **только первый** подходящий преобразователь

```php
// Будет вызываться вторым
$exchange->addPrepared($myPreparation);

// Будет вызываться первым
$exchange->addPrepared($preparation2);
```